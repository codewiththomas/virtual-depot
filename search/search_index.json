{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Virtual Depot The goal is to create a virtual depot that can be used to trade on the stock market. The depot should be able to trade on The goal is to create a trading bot that can be used to trade on the stock market. The bot should be able to trade on different stock exchanges and with different assets. The bot should be able to trade with different strategies and should be able to learn from the past. Basic Idea Goal: Check depot once a day and decide if trades should be made For 30 days period, the depot should not drop below 90% Target is to maximize the depot value Setting up the bot the bot gets a virtual start balance the bot gets a virtual depot the bot gets a list of all tradeable assets the bot gets an imaginary date (allows us to test the bot in the past) give bot the info that each trade costs a certain amount of money (1 EUR) Preparing data basis pull financial data from the Yahoo Finance API for each asset store the data in a SQLite database use incremental updates (first run, pull max period for each asset, then pull and save only the new data) Enrich data basis calculate KPIs for each asset SMA (Simple Moving Average) - short, medium, long RSI (Relative Strength Index) Bollinger Bands MACD (Moving Average Convergence Divergence) OBV (On Balance Volume) Trading decide if any assets should be sold in order to buy better ones Financial Data The fincancial data are pulled from the Yahoo Finance API and stored in a SQLite database. Asset - as single asset Depot - as depot of assets Bot - as trading bot KPIs for single instruments Short SMA (20 Tage) Long SMS (50 Tage) RSI (14-Tage) Bollinger Bands (n=20, up/down) MACD (Moving Average Convergence Divergence) OBV (On Balance Volume) Volatility Sharpe Ratio Max loss","title":"Virtual Depot"},{"location":"#virtual-depot","text":"The goal is to create a virtual depot that can be used to trade on the stock market. The depot should be able to trade on The goal is to create a trading bot that can be used to trade on the stock market. The bot should be able to trade on different stock exchanges and with different assets. The bot should be able to trade with different strategies and should be able to learn from the past.","title":"Virtual Depot"},{"location":"#basic-idea","text":"Goal: Check depot once a day and decide if trades should be made For 30 days period, the depot should not drop below 90% Target is to maximize the depot value Setting up the bot the bot gets a virtual start balance the bot gets a virtual depot the bot gets a list of all tradeable assets the bot gets an imaginary date (allows us to test the bot in the past) give bot the info that each trade costs a certain amount of money (1 EUR) Preparing data basis pull financial data from the Yahoo Finance API for each asset store the data in a SQLite database use incremental updates (first run, pull max period for each asset, then pull and save only the new data) Enrich data basis calculate KPIs for each asset SMA (Simple Moving Average) - short, medium, long RSI (Relative Strength Index) Bollinger Bands MACD (Moving Average Convergence Divergence) OBV (On Balance Volume) Trading decide if any assets should be sold in order to buy better ones","title":"Basic Idea"},{"location":"#financial-data","text":"The fincancial data are pulled from the Yahoo Finance API and stored in a SQLite database. Asset - as single asset Depot - as depot of assets Bot - as trading bot","title":"Financial Data"},{"location":"#kpis-for-single-instruments","text":"Short SMA (20 Tage) Long SMS (50 Tage) RSI (14-Tage) Bollinger Bands (n=20, up/down) MACD (Moving Average Convergence Divergence) OBV (On Balance Volume) Volatility Sharpe Ratio Max loss","title":"KPIs for single instruments"},{"location":"getting-started/","text":"Getting Started Start the application Clone repo. git clone https://github.com/codewiththomas/virtual-depot.git Create a virtual environment. py -3.12 -m venv .venv Activate virtual environment. .venv\\Scripts\\activate Install dependencies. pip install -r requirements.txt Navigate to /src folder. cd src Run the app. python main.py Code Structure src/ \u251c\u2500\u2500 app.py # Entry point for the Flask-App \u251c\u2500\u2500 config.py # Configuration as database connection string \u251c\u2500\u2500 requirements.txt # Dependency management \u251c\u2500\u2500 daily_update.py # Script for daily update of financial data \u251c\u2500\u2500 data_service.py # Service to pull financial data from Yahoo Finance API and write to database \u251c\u2500\u2500 indicators.py # Various functions to calculate KPIs \u251c\u2500\u2500 models.py # SQLAlchemy-Models \u251c\u2500\u2500 static/ # Folder for static files (Bootstrap, CSS, JS) \u251c\u2500\u2500 templates/ # HTML-Templates \u2514\u2500\u2500 ...","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#start-the-application","text":"Clone repo. git clone https://github.com/codewiththomas/virtual-depot.git Create a virtual environment. py -3.12 -m venv .venv Activate virtual environment. .venv\\Scripts\\activate Install dependencies. pip install -r requirements.txt Navigate to /src folder. cd src Run the app. python main.py","title":"Start the application"},{"location":"getting-started/#code-structure","text":"src/ \u251c\u2500\u2500 app.py # Entry point for the Flask-App \u251c\u2500\u2500 config.py # Configuration as database connection string \u251c\u2500\u2500 requirements.txt # Dependency management \u251c\u2500\u2500 daily_update.py # Script for daily update of financial data \u251c\u2500\u2500 data_service.py # Service to pull financial data from Yahoo Finance API and write to database \u251c\u2500\u2500 indicators.py # Various functions to calculate KPIs \u251c\u2500\u2500 models.py # SQLAlchemy-Models \u251c\u2500\u2500 static/ # Folder for static files (Bootstrap, CSS, JS) \u251c\u2500\u2500 templates/ # HTML-Templates \u2514\u2500\u2500 ...","title":"Code Structure"},{"location":"persistence/","text":"Persistence The database access is managed by ORM tool SQLAlchemy . The application uses SQLite as database. The database itself will be created in the src folder as depot.db when the application is executed. The database schema is divided into three parts: Asset, Depot, and Transactions. Their corresponding classes are all stored in the file models.py . Assets Whenever the user searches for an asset, the asset is stored in the database (if it exists). The asset is identified by its ticker symbol (e.g. MSFT or AAPL ). The type can be either STOCK or ETF . Together with the asset its historical price data is stored. erDiagram asset ||--o{ price_history : \"has\" asset { int id PK string(50) symbol UK string(100) name string(20) asset_type \"STOCK, ETF\" } price_history { int id PK int asset_id FK datetime date float open_price float high_price float low_price float close_price int volume float dividends float split_factor datetime created_at } As app grows, it could be considered to add ISIN/WKN to the asset table. Depots The depot is the main entity of the application. It holds the cash balance and the assets the user owns. The user can have multiple depots. The depot is identified by its ID. The holding table stores the assets the user owns in the depot. It is optimized for fast read access. erDiagram depot ||--o{ holding : \"has\" depot { int id PK float balance } holding { int id PK int depot_id FK int asset_id FK float quantity float average_cost float total_fees datetime created_at } Transactions The transaction table stores all transactions the user has made. It is optimized for fast write access and to analyze historical data. erDiagram transaction { int id PK int depot_id FK int asset_id FK string(10) transaction_type \"BUY, SELL\" float quantity float price_per_unit float fee datetime timestamp }","title":"Persistence"},{"location":"persistence/#persistence","text":"The database access is managed by ORM tool SQLAlchemy . The application uses SQLite as database. The database itself will be created in the src folder as depot.db when the application is executed. The database schema is divided into three parts: Asset, Depot, and Transactions. Their corresponding classes are all stored in the file models.py .","title":"Persistence"},{"location":"persistence/#assets","text":"Whenever the user searches for an asset, the asset is stored in the database (if it exists). The asset is identified by its ticker symbol (e.g. MSFT or AAPL ). The type can be either STOCK or ETF . Together with the asset its historical price data is stored. erDiagram asset ||--o{ price_history : \"has\" asset { int id PK string(50) symbol UK string(100) name string(20) asset_type \"STOCK, ETF\" } price_history { int id PK int asset_id FK datetime date float open_price float high_price float low_price float close_price int volume float dividends float split_factor datetime created_at } As app grows, it could be considered to add ISIN/WKN to the asset table.","title":"Assets"},{"location":"persistence/#depots","text":"The depot is the main entity of the application. It holds the cash balance and the assets the user owns. The user can have multiple depots. The depot is identified by its ID. The holding table stores the assets the user owns in the depot. It is optimized for fast read access. erDiagram depot ||--o{ holding : \"has\" depot { int id PK float balance } holding { int id PK int depot_id FK int asset_id FK float quantity float average_cost float total_fees datetime created_at }","title":"Depots"},{"location":"persistence/#transactions","text":"The transaction table stores all transactions the user has made. It is optimized for fast write access and to analyze historical data. erDiagram transaction { int id PK int depot_id FK int asset_id FK string(10) transaction_type \"BUY, SELL\" float quantity float price_per_unit float fee datetime timestamp }","title":"Transactions"},{"location":"update-docs/","text":"Update documentation Go the same way as starting the app. After environment has been activated, navigate to /docs folder. cd docs Start a webserver. mkdocs serve The website is now available at http://127.0.0.1:8000 . If you want to build the documentation only, run the following command: mkdocs build This generates a /site folder with the static files for the documentation website.","title":"Update documentation"},{"location":"update-docs/#update-documentation","text":"Go the same way as starting the app. After environment has been activated, navigate to /docs folder. cd docs Start a webserver. mkdocs serve The website is now available at http://127.0.0.1:8000 . If you want to build the documentation only, run the following command: mkdocs build This generates a /site folder with the static files for the documentation website.","title":"Update documentation"}]}